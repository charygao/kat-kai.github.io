---
layout: post
title: ESP8266/ESP32でのCPUクロック数取得
outline: CPUクロック数を取得して、マイクロ秒オーダーでのGPIO制御の実現
---

## はじめに

ESP8266/ESP32で遊んでいるとマイクロ秒オーダーで、GPIOを制御したくなるときがあるかもしれません。

そんな時には、CPUクロック数を用いることで概ね実現できます。
通常、ESP8266では80MHz, ESP32では160MHzで駆動しており、
CPUクロック数は、1秒間に80,000,000(ESP8266)、160,000,000(ESP32)増加します。


## 実装
まず関数get_ccount()を定義します。
```
static inline unsigned get_ccount(void)
{
   unsigned r;
   asm volatile ("rsr %0, ccount" : "=r"(r));
   return r;
}
```

そしてESP32/ESP-IDFの場合、1マイクロ秒LOW、3マイクロ秒HIGH、その後再びLOWにしたいときには以下のコードで実現できます。

ESP32では1マイクロ秒間にCPUクロック数は160増加します。待ち時間に応じた数字をwhileの条件式に代入することで、マイクロ秒オーダでのGPIO制御が可能となります。

```
long startCount;

startCount = get_ccount();
gpio_set_level(GPIO_INPUT_IO_0, LOW);
while (get_ccount() - startCount < 160) __asm__ __volatile__ ("nop");

startCount = get_ccount();
gpio_set_level(GPIO_INPUT_IO_0, HIGH);
while (get_ccount() - startCount < 160*3) __asm__ __volatile__ ("nop");

gpio_set_level(GPIO_INPUT_IO_0, LOW);
```

誤差はおよそ0.1マイクロ秒程度であり、1Mbpsの通信は十分行えました。さらに厳密に時間調整したい場合は、whileのループ外にもNOPすることで可能になります。

## 参考にしたページ
http://bbs.espressif.com/viewtopic.php?t=200